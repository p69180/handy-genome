import os
import re
import subprocess
import time
from pprint import pprint

import pysam

import importlib
top_package_name = __name__.split('.')[0]
common = importlib.import_module('.'.join([top_package_name, 'common']))
workflow = importlib.import_module('.'.join([top_package_name, 'workflow']))
infoformat = importlib.import_module('.'.join([top_package_name, 'variantplus', 'infoformat']))
variantplus = importlib.import_module('.'.join([top_package_name, 'variantplus', 'variantplus']))
headerhandler = importlib.import_module('.'.join([top_package_name, 'variantplus', 'headerhandler']))
ensembl_rest = importlib.import_module('.'.join([top_package_name, 'annotation', 'ensembl_rest']))
#ensembl_parser = importlib.import_module('.'.join([top_package_name, 'annotation', 'ensembl_parser']))


RE_PATS = dict()
RE_PATS['CSQ_INFOmeta'] = re.compile('^Consequence annotations from Ensembl VEP. Format: ([^|]+(\|[^|]+)*)$')

COMMON_DESCRIPTION = 'VEP annotation, modified from original VEP vcf output format.'
VEP_INFOkeys = {
	'nonSV': {
		'ID' : 'VEPannot',
		'Description' : COMMON_DESCRIPTION,
	},
	'bnd1': {
		'ID' : 'VEPannot_bnd1',
		'Description' : f'(For breakend 1) {COMMON_DESCRIPTION}',
	},
	'bnd2': {
		'ID' : 'VEPannot_bnd2',
		'Description' : f'(For breakend 2) {COMMON_DESCRIPTION}',
	},
	'interval': {
		'ID' : 'VEPannot_interval',
		'Description' : f'(For the interval between two breakends. Only relevant when two breakens are on the same chromosome.) {COMMON_DESCRIPTION}',
	},
}

DEFAULT_JOBNAME = 'VEP'


class VEPannot:
	def __init__(self, feat_list, VEPkeys):
		self.features = feat_list
		self.canonical_features = [ x for x in self.features if x.is_canonical ]
		self.VEPkeys = VEPkeys

	def to_info_value(self, output_keys = None):
		if output_keys is None:
			output_keys = self.VEPkeys

		info_value = list()
		for feat in self.features:
			annot_string_list = list()
			for key in output_keys:
				if key in feat.items:
					if feat.items[key] is None:
						val = '.'
					else:
						val = feat.items[key]
				else:
					val = '.'

				annot_string_list.append(f'{key}:::{val}')
			annot_string = '|'.join(annot_string_list)
			info_value.append(annot_string)

		return info_value

	def write_to_pysamvr_nonSV(self, pysamvr, output_keys = None):
		assert VEP_INFOkeys['nonSV']['ID'] in pysamvr.header.info.keys()
		pysamvr.info['nonSV'] = self.to_info_value(output_keys)

	def write_to_pysamvr_bnd1(self, pysamvr, output_keys = None):
		assert VEP_INFOkeys['bnd1']['ID'] in pysamvr.header.info.keys()
		pysamvr.info['bnd1'] = self.to_info_value(output_keys)
				
	def write_to_pysamvr_bnd2(self, pysamvr, output_keys = None):
		assert VEP_INFOkeys['bnd2']['ID'] in pysamvr.header.info.keys()
		pysamvr.info['bnd2'] = self.to_info_value(output_keys)
				
	def write_to_pysamvr_interval(self, pysamvr, output_keys = None):
		assert VEP_INFOkeys['interval']['ID'] in pysamvr.header.info.keys()
		pysamvr.info['interval'] = self.to_info_value(output_keys)


def get_vepannot_pysamvr(pysamvr, INFOkey, VEPkeys = None, hg19 = True):
	"""
	Parses a pysam.VariantRecord object derived from a VEP output vcf file.

	Returns: A VEPannot class object
	"""

	if VEPkeys is None:
		VEPkeys = get_VEPkeys(pysamvr.header)
		if VEPkeys is None:
			return None

	feat_list = feature.get_feature_list_pysamvr(pysamvr, INFOkey, VEPkeys, hg19 = hg19)
	if feat_list is None:
		return None

	vepannot = VEPannot(feat_list, VEPkeys)

	return vepannot


##################################################################################
	

def get_VEPkeys(pysamhdr):
	"""
	Args:
		pysamhdr: pysam.VariantHeader object. Source vcf record must be annotated with VEP.
	
	Returns:
		A list composed of VEP annotation subfield names. An empty list if VEP annotation header is absent.
	"""

	if 'CSQ' in pysamhdr.info:
		mat = RE_PATS['CSQ_INFOmeta'].match(
				pysamhdr.info['CSQ'].description
				)
		if mat is None:
			#VEPkeys = list()
			VEPkeys = None
		else:
			VEPkeys = mat.group(1).split('|')
	else:
		#VEPkeys = list()
		VEPkeys = None

	return VEPkeys


def get_VEPannot_format(pysamvr, VEPkeys):
	"""
	Args:
		pysamvr : pysam.VariantRecord object

	Returns:
		A tuple (VEPkeys, is_VEPannot, is_splitVEPannot).
		VEPkeys: A list composed of VEP annotation subfield names.
		is_VEPannot: True iff 1) VEPkeys is not None 2) has non-MISSING "CSQ" field or split CSQ fields in INFO.
		is_splitVEPannot: True if VEP INFO fields consist of "CSQ_*" fields ; False if VEP INFO field only include "CSQ".
	"""

	if VEPkeys is None:
		is_VEPannot = False
		is_splitVEPannot = None
	else:
		CSQfields = set(['CSQ'])
		CSQfields_split = set('CSQ_' + x for x in VEPkeys)
		INFOkeys = set(pysamvr.info.keys())

		if CSQfields_split.issubset(INFOkeys):
			is_VEPannot = True
			is_splitVEPannot = True
		elif CSQfields.issubset(INFOkeys):
			if infoformat.check_NA_info(pysamvr, 'CSQ'):
				is_VEPannot = False
				is_splitVEPannot = None
			else:
				is_VEPannot = True
				is_splitVEPannot = False
		else:
			is_VEPannot = False
			is_splitVEPannot = None

	return is_VEPannot, is_splitVEPannot


def remove_VEP_annotation(pysamvr):
	for key in pysamvr.info:
		if key.startswith('CSQ'):
			pysamvr.info.__delitem__(key)


def add_splitVEPkey_toheader_onekey(key, pysamhdr):
	"""
	pysamhdr: pysam.VariantHeader object.
	"""

	newkey = 'CSQ_'+key
	if newkey not in pysamhdr.info:
		pysamhdr.add_meta(
				key = 'INFO',
				items = [
					('ID', newkey),
					('Number', '.'),
					('Type', 'String'),
					('Description', f'Comma-separated VEP annotations for "{key}".'),
					],
				)


def add_splitVEPkey_toheader(VEPkeys, pysamhdr):
	"""
	pysamhdr: pysam.VariantHeader object.
	"""

	for key in VEPkeys:
		add_splitVEPkey_toheader_onekey(key, pysamhdr)



def add_INFOkey_common(pysamhdr, role):
	pysamhdr.add_meta(
			key = 'INFO',
			items = [
			('ID', VEP_INFOkeys[role]['ID']), ('Type', 'String'), ('Number','.'), 
			('Description', VEP_INFOkeys[role]['Description']),
			],
			)


def add_INFOkey_nonSV(pysamhdr):
	add_INFOkey_common(pysamhdr, 'nonSV')


def add_INFOkey_bnd1(pysamhdr):
	add_INFOkey_common(pysamhdr, 'bnd1')


def add_INFOkey_bnd2(pysamhdr):
	add_INFOkey_common(pysamhdr, 'bnd2')


def add_INFOkey_interval(pysamhdr):
	add_INFOkey_common(pysamhdr, 'interval')


# functions for VEP running


def check_species_assembly_sanity(species, assembly):
	common.check_arg_choices(species, 'species', ('homo_sapiens', 'mus_musculus'))
	if species == 'homo_sapiens':
		common.check_arg_choices(assembly, 'assembly', ('GRCh37', 'GRCh38'))
	elif species == 'mus_musculus':
		common.check_arg_choices(assembly, 'assembly', ('GRCm38', 'GRCm39'))


def make_vep_jobscript(
		infile_path, 
		outfile_path, 
		fasta_path,
		species, 
		assembly,
		jobscript_path,
		distance = 5000,
		log_path = None,
		jobname = DEFAULT_JOBNAME,
		force_overwrite = True,
		):
	if log_path is None:
		log_path = jobscript_path + '.log'

	common.check_infile_validity(infile_path)
	for path in (outfile_path, jobscript_path, log_path):
		common.check_outfile_validity(path)
	check_species_assembly_sanity(species, assembly)

	if species == 'mus_musculus' and assembly == 'GRCm38':
		vep_path = common.VEP_MM10
	else:
		vep_path = common.VEP

	max_chrom_size = max(common.ChromDict(fasta_path = fasta_path).lengths)

	vep_lines = [
		vep_path,
		f'-i {infile_path}',
		f'-o {outfile_path}',
		f'--fasta {fasta_path}',
		f'--species {species}',
		f'--assembly {assembly}',
		f'--max_sv_size {max_chrom_size}',

		f'--dir {common.VEP_CACHE_DIR}',
		'--cache',
		'--offline',

		'--vcf',
		'--vcf_info_field CSQ',
		'--terms SO',
		'--shift_hgvs 0',
		'--dont_skip',
		'--no_stats',

		f'--distance {distance}',

		'--symbol',
		'--numbers',
		'--hgvsg',
		'--hgvs',
		'--ccds',
		#'--mirna',
		'--biotype',
		'--canonical',
		#'--xref_refseq',
		'--mane',

		'--regulatory',

		'--protein',
		'--uniprot',
		'--sift b',
		'--polyphen b',

		#'--check_existing',
		#'--pubmed',
		#'--af',

		#'--max_af',
		#'--af_1kg',
		#'--af_esp',
		#'--af_gnomad',
		#'--var_synonyms',

		#'--nearest transcript',
	]

	if force_overwrite:
		vep_lines.append('--force_overwrite')

	vep_command = workflow.make_multiline_command(vep_lines, leading_taps = 0)

	workflow.make_jobscript(
			jobscript_path, 
			lines = [f'exec &> {log_path}', vep_command], 
			c = 2, 
			J = jobname,
			)


def run_vep_local(
		infile_path, 
		outfile_path, 
		fasta_path,
		species, 
		assembly,
		distance = 5000,
		jobscript_path = common.get_tempfile_path(delete = True),
		log_path = None,
		rm_scripts = False,
		):
	if log_path is None:
		log_path = jobscript_path + '.log'

	make_vep_jobscript(
			infile_path, 
			outfile_path, 
			fasta_path,
			species, 
			assembly,
			jobscript_path,
			distance = distance,
			log_path = log_path,
			)
	success, returncode_list = workflow.run_jobs_local([jobscript_path])
	if not success:
		e_msg = f'''\
[{common.get_timestamp()}] VEP finished with an error.
script used to run VEP: {jobscript_path}'''
		raise Exception(e_msg)

	if rm_scripts:
		os.remove(jobscript_path)
		os.remove(log_path)


def make_vep_job(
		jobscript_path,
		log_path,
		infile_path, 
		outfile_path, 
		fasta_path,
		species, 
		assembly,
		jobname = DEFAULT_JOBNAME,
		):
	make_vep_jobscript(
			infile_path, 
			outfile_path, 
			fasta_path,
			species, 
			assembly,
			jobscript_path,
			log_path = log_path,
			jobname = jobname,
			)
	job = workflow.Job(jobscript_path = jobscript_path)
	
	return job


def run_vep_pysamvr(
		pysamvr,
		fasta_path,
		species, 
		assembly,
		distance = 5000,
		):
	input_vcf_path = common.get_tempfile_path(delete = True)
	output_vcf_path = common.get_tempfile_path(delete = True)

	with pysam.VariantFile(input_vcf_path, 'w', header = pysamvr.header) as input_vcf:
		input_vcf.write(pysamvr)

	run_vep_local(
			infile_path = input_vcf_path,
			outfile_path = output_vcf_path,
			fasta_path = fasta_path,
			species = species,
			assembly = assembly,
			distance = distance,
			rm_scripts = True,
			)
	output = next(pysam.VariantFile(output_vcf_path, 'r').fetch())

	os.remove(input_vcf_path)
	os.remove(output_vcf_path)

	return output


def run_vep_minimal(
		chrom, 
		pos, 
		ref, 
		alt,
		fasta_path, 
		species, 
		assembly,
		):
	chromdict = common.ChromDict(fasta_path = fasta_path)
	pysamvr = headerhandler.create_pysamvr(chrom, pos, ref, alt, chromdict)
	pysamvr_annot = run_vep_pysamvr(pysamvr, fasta_path, species, assembly)
	with pysam.FastaFile(fasta_path) as fasta:
		vp = variantplus.VariantPlus(pysamvr_annot, fasta, chromdict)
		vep_dict = vp.VEPannot_dict
		canonical_vep_dict = vp.canonical_VEPannot_dict

	return vep_dict, canonical_vep_dict


# functions for VEP running - for SV


def get_header_for_VEPinput(chromdict):
	new_header = headerhandler.create_empty_header(chromdict = chromdict)
	headerhandler.add_INFOmeta(new_header, ID = 'GID', Type = 'Integer', Number = 1, Description = '')
	headerhandler.add_INFOmeta(new_header, ID = 'ROLE', Type = 'String', Number = 1, Description = '')

	return new_header


def convert_vpp_to_vepinput(vpp, gid, new_header = None):
	def get_pysamvr_nonSV(pysamvr, new_header, gid):
		pysamvr = headerhandler.create_pysamvr(
				chrom = pysamvr.contig,
				pos = pysamvr.pos,
				ref = pysamvr.ref,
				alt = pysamvr.alts[0],
				pysamhdr = new_header, 
				use_pysamhdr = True,
				)
		pysamvr.info['GID'] = gid
		pysamvr.info['ROLE'] = 'nonSV'

		return pysamvr

	def get_alt(ref):
		return 'C' if ref == 'A' else 'A'

	def get_pysamvr_bnd12(bnds, new_header, gid, bnd1 = False, bnd2 = False):
		assert [bnd1, bnd2].count(True) == 1

		chrom, pos = (bnds.chrom1, bnds.pos1) if bnd1 else (bnds.chrom2, bnds.pos2)
		ref = bnds.fasta.fetch(chrom, pos - 1, pos)
		assert ref != 'N'
		alt = get_alt(ref)

		pysamvr = headerhandler.create_pysamvr(
				chrom = chrom,
				pos = pos,
				ref = ref,
				alt = alt,
				pysamhdr = new_header, 
				use_pysamhdr = True,
				)
		pysamvr.info['GID'] = gid
		pysamvr.info['ROLE'] = 'bnd1' if bnd1 else 'bnd2'

		return pysamvr

	def get_pysamvr_interval(bnds, new_header, gid):
		# creating an interval where the first point is bnds.pos1 and the last point is bnds.pos2
		start = bnds.pos1 - 1
		end = bnds.pos2
		length_for_vep_cutoff = end - start - 1

		if bnds.chrom1 == bnds.chrom2:
			# VEP results in error when length_for_vep_cutoff is greater than 10_000_000
			# Empirically known condition for proper VEP running is: INFO/END - POS < 10_000_002
			if length_for_vep_cutoff <= 10_000_000:
				available = True
			else: 
				available = False
		else:
			available = False

		if available:
			pysamvr_interval = headerhandler.create_pysamvr(
					chrom = bnds.chrom1,
					pos = start,
					ref = 'N',
					alt = '<DUP>',
					pysamhdr = new_header, 
					use_pysamhdr = True,
					)
			pysamvr_interval.stop = end
			pysamvr_interval.info['GID'] = gid
			pysamvr_interval.info['ROLE'] = 'interval'
		else:
			pysamvr_interval = None

		return pysamvr_interval

	def get_pysamvr_interval_list(bnds, new_header, gid):
		# creating an interval where the first point is bnds.pos1 and the last point is bnds.pos2
		if bnds.chrom1 == bnds.chrom2:
			cutoff = 10_000_001
			start = bnds.pos1 - 1
			end = bnds.pos2

			pair_list = list()
			pair_list.append([start])
			while True:
				if pair_list[-1][0] + cutoff < end:
					pair_list[-1].append(pair_list[-1][0] + cutoff)
					pair_list.append([ pair_list[-1][1] ])
				else:
					pair_list[-1].append(end)
					break

			pysamvr_interval_list = list()
			for pair in pair_list:
				pysamvr_interval = headerhandler.create_pysamvr(
						chrom = bnds.chrom1,
						pos = pair[0],
						ref = 'N',
						alt = '<DUP>',
						pysamhdr = new_header, 
						use_pysamhdr = True,
						)
				pysamvr_interval.stop = pair[1]
				pysamvr_interval.info['GID'] = gid
				pysamvr_interval.info['ROLE'] = 'interval'
				pysamvr_interval_list.append(pysamvr_interval)
		else:
			pysamvr_interval_list = None

		return pysamvr_interval_list

	if new_header is None:
		new_header = get_header_for_VEPinput(vpp.chromdict)

	if vpp.is_SV:
		bnds = vpp.bnds_maxspan_pos1
		pysamvr_bnd1 = get_pysamvr_bnd12(bnds, new_header, gid, bnd1 = True)
		pysamvr_bnd2 = get_pysamvr_bnd12(bnds, new_header, gid, bnd2 = True)
		#pysamvr_interval = get_pysamvr_interval(bnds, new_header, gid)
		pysamvr_interval_list = get_pysamvr_interval_list(bnds, new_header, gid)

		#return pysamvr_bnd1, pysamvr_bnd2, pysamvr_interval
		return [ pysamvr_bnd1, pysamvr_bnd2 ] + pysamvr_interval_list
	else:
		pysamvr = get_pysamvr_nonSV(vpp.vp1.pysamvr, new_header, gid)
		return [ pysamvr ]





# functions for SV annotation



